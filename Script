-- Hacking Simulator (Rayfield) - LocalScript (Studio/Test only)
-- Place into StarterPlayer -> StarterPlayerScripts
-- Safety: For Studio / your own places only. Do not use against other people's games.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

-- Load Rayfield
local ok, Rayfield = pcall(function()
    return loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
end)
if not ok or not Rayfield then
    warn("Failed to load Rayfield. Ensure HttpGet is allowed or embed Rayfield locally.")
    return
end

-- Predeclare shared state for keybind aiming
local aimingKeyHeld = false
local aimingMouseDown = false

-- Some helper getters
local function getCharacter()
    return LocalPlayer and LocalPlayer.Character
end
local function getHumanoid()
    local c = getCharacter()
    return c and c:FindFirstChildOfClass("Humanoid")
end
local function getHRP(character)
    if not character then return nil end
    return character:FindFirstChild("HumanoidRootPart") or character:FindFirstChildWhichIsA("BasePart")
end

-- Basic "hacker" theme (default startup)
local HackerTheme = {
    TextColor = Color3.fromRGB(240, 240, 240),

    Background = Color3.fromRGB(20, 20, 20),
    Topbar = Color3.fromRGB(28, 28, 28),
    Shadow = Color3.fromRGB(10, 10, 10),

    NotificationBackground = Color3.fromRGB(14, 14, 14),
    NotificationActionsBackground = Color3.fromRGB(230, 230, 230),

    TabBackground = Color3.fromRGB(60, 60, 60),
    TabStroke = Color3.fromRGB(65, 65, 65),
    TabBackgroundSelected = Color3.fromRGB(210, 210, 210),
    TabTextColor = Color3.fromRGB(240, 240, 240),
    SelectedTabTextColor = Color3.fromRGB(30, 30, 30),

    ElementBackground = Color3.fromRGB(12,12,12),
    ElementBackgroundHover = Color3.fromRGB(22,22,22),
    SecondaryElementBackground = Color3.fromRGB(10,10,10),
    ElementStroke = Color3.fromRGB(40, 40, 40),
    SecondaryElementStroke = Color3.fromRGB(30, 30, 30),
            
    SliderBackground = Color3.fromRGB(0, 170, 0),
    SliderProgress = Color3.fromRGB(0, 170, 0),
    SliderStroke = Color3.fromRGB(0, 200, 0),

    ToggleBackground = Color3.fromRGB(10, 10, 10),
    ToggleEnabled = Color3.fromRGB(0, 255, 150),
    ToggleDisabled = Color3.fromRGB(100, 100, 100),
    ToggleEnabledStroke = Color3.fromRGB(0, 200, 120),
    ToggleDisabledStroke = Color3.fromRGB(125, 125, 125),
    ToggleEnabledOuterStroke = Color3.fromRGB(60, 60, 60),
    ToggleDisabledOuterStroke = Color3.fromRGB(40, 40, 40),

    DropdownSelected = Color3.fromRGB(25,25,25),
    DropdownUnselected = Color3.fromRGB(14,14,14),

    InputBackground = Color3.fromRGB(12,12,12),
    InputStroke = Color3.fromRGB(40,40,40),
    PlaceholderColor = Color3.fromRGB(140,140,140)
}

-- Collection of predefined themes (simple variations). You can tweak colors here.
local Themes = {
    Default = HackerTheme,
    AmberGlow = {
        TextColor = Color3.fromRGB(240,240,240),
        Background = Color3.fromRGB(22, 16, 7),
        Topbar = Color3.fromRGB(40, 20, 6),
        SliderBackground = Color3.fromRGB(255,150,0),
        SliderProgress = Color3.fromRGB(255,150,0),
        ToggleEnabled = Color3.fromRGB(255,180,80),
        ElementBackground = Color3.fromRGB(12,8,3),
    },
    Amethyst = {
        TextColor = Color3.fromRGB(245,240,255),
        Background = Color3.fromRGB(18,6,30),
        Topbar = Color3.fromRGB(30,12,50),
        SliderBackground = Color3.fromRGB(160,32,240),
        SliderProgress = Color3.fromRGB(160,32,240),
        ToggleEnabled = Color3.fromRGB(200,80,230),
    },
    Bloom = {
        TextColor = Color3.fromRGB(20,20,20),
        Background = Color3.fromRGB(240,240,240),
        Topbar = Color3.fromRGB(255,255,255),
        SliderBackground = Color3.fromRGB(255,100,140),
        SliderProgress = Color3.fromRGB(255,100,140),
        ToggleEnabled = Color3.fromRGB(255,60,100),
        ElementBackground = Color3.fromRGB(250,250,250),
    },
    DarkBlue = {
        TextColor = Color3.fromRGB(230,240,255),
        Background = Color3.fromRGB(6,12,28),
        Topbar = Color3.fromRGB(8,16,36),
        SliderBackground = Color3.fromRGB(40,120,255),
        SliderProgress = Color3.fromRGB(40,120,255),
        ToggleEnabled = Color3.fromRGB(80,180,255),
    },
    Green = {
        TextColor = Color3.fromRGB(230,255,230),
        Background = Color3.fromRGB(5,18,5),
        Topbar = Color3.fromRGB(6,24,6),
        SliderBackground = Color3.fromRGB(0,200,0),
        SliderProgress = Color3.fromRGB(0,200,0),
        ToggleEnabled = Color3.fromRGB(0,255,120),
    },
    Light = {
        TextColor = Color3.fromRGB(30,30,30),
        Background = Color3.fromRGB(245,245,245),
        Topbar = Color3.fromRGB(230,230,230),
        SliderBackground = Color3.fromRGB(70,130,180),
        SliderProgress = Color3.fromRGB(70,130,180),
        ToggleEnabled = Color3.fromRGB(60,160,140),
        ElementBackground = Color3.fromRGB(255,255,255),
    },
    Ocean = {
        TextColor = Color3.fromRGB(235,245,250),
        Background = Color3.fromRGB(6,30,40),
        Topbar = Color3.fromRGB(6,36,50),
        SliderBackground = Color3.fromRGB(20,200,180),
        SliderProgress = Color3.fromRGB(20,200,180),
        ToggleEnabled = Color3.fromRGB(80,240,200),
    },
    Serenity = {
        TextColor = Color3.fromRGB(230,235,245),
        Background = Color3.fromRGB(12,20,30),
        Topbar = Color3.fromRGB(18,28,40),
        SliderBackground = Color3.fromRGB(120,150,255),
        SliderProgress = Color3.fromRGB(120,150,255),
        ToggleEnabled = Color3.fromRGB(160,200,255),
    }
}

-- Utility to apply theme: tries a few common Rayfield APIs, then falls back to setting Window.Theme if present.
local function applyThemeByIdentifier(id, window)
    local themeTable = Themes[id] or Themes.Default
    local applied = false

    -- try several plausible APIs (some Rayfield forks expose different names)
    local ok, err

    if window and window.ApplyTheme then
        ok, err = pcall(function() window:ApplyTheme(themeTable) end)
        applied = applied or ok
    end

    if not applied and Rayfield.ApplyTheme then
        ok, err = pcall(function() Rayfield:ApplyTheme(themeTable) end)
        applied = applied or ok
    end

    if not applied and Rayfield.ChangeTheme then
        ok, err = pcall(function() Rayfield:ChangeTheme(themeTable) end)
        applied = applied or ok
    end

    if not applied and Rayfield.Theme then
        -- try setting global theme directly
        pcall(function() Rayfield.Theme = themeTable end)
        applied = true
    end

    -- last resort: try mutating window.Theme then triggering a repaint (not always available)
    if not applied and window then
        pcall(function()
            window.Theme = themeTable
            if window.UpdateTheme then window:UpdateTheme() end
            if window:Refresh then window:Refresh() end
        end)
        applied = true
    end

    return applied
end

-- Create Rayfield window
local Window = Rayfield:CreateWindow({
    Name = "Hacking Sim (Studio)",
    LoadingTitle = "Hacking Simulator",
    LoadingSubtitle = "Local / Test Only",
    ToggleUIKeybind = "K",
    Theme = HackerTheme,
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "HackingSimConfigs",
        FileName = "Default"
    },
    DisableRayfieldPrompts = true
})

-- ===================== Build Tabs & UI =====================

-- MAIN TAB
local mainTab = Window:CreateTab("Main", "zap")
mainTab:CreateSection("Movement & Utility")

-- WalkSpeed
local speedSlider = mainTab:CreateSlider({
    Name = "WalkSpeed",
    Range = {0, 500},
    Increment = 1,
    Suffix = "WS",
    CurrentValue = 16,
    Flag = "SpeedSlider",
    Callback = function(value)
        if speedToggle and speedToggle.CurrentValue then
            local hum = getHumanoid()
            if hum then hum.WalkSpeed = value end
        end
    end
})
local speedToggle = mainTab:CreateToggle({
    Name = "Speed On/Off",
    CurrentValue = false,
    Flag = "SpeedToggle",
    Callback = function(on)
        local hum = getHumanoid()
        if on then if hum then hum.WalkSpeed = speedSlider.CurrentValue end
        else if hum then hum.WalkSpeed = 16 end end
    end
})

-- JumpPower
local jumpSlider = mainTab:CreateSlider({
    Name = "JumpPower",
    Range = {0,500},
    Increment = 1,
    Suffix = "JP",
    CurrentValue = 50,
    Flag = "JumpSlider",
    Callback = function(value)
        if jumpToggle and jumpToggle.CurrentValue then
            local hum = getHumanoid()
            if hum then hum.JumpPower = value end
        end
    end
})
local jumpToggle = mainTab:CreateToggle({
    Name = "JumpPower On/Off",
    CurrentValue = false,
    Flag = "JumpToggle",
    Callback = function(on)
        local hum = getHumanoid()
        if on then if hum then hum.JumpPower = jumpSlider.CurrentValue end
        else if hum then hum.JumpPower = 50 end end
    end
})

-- Infinite Jump
local infJumpToggle = mainTab:CreateToggle({
    Name = "Infinite Jump",
    CurrentValue = false,
    Flag = "InfJump",
    Callback = function(on) end
})

-- Noclip
local noclipToggle = mainTab:CreateToggle({
    Name = "Noclip",
    CurrentValue = false,
    Flag = "Noclip",
    Callback = function(on) end
})

-- Infinite Health
local infHealthToggle = mainTab:CreateToggle({
    Name = "Infinite Health",
    CurrentValue = false,
    Flag = "InfiniteHealth",
    Callback = function(on) end
})

-- Anti-AFK
local antiAfkToggle = mainTab:CreateToggle({
    Name = "Anti-AFK",
    CurrentValue = true,
    Flag = "AntiAFK",
    Callback = function(on) end
})

-- TELEPORT TAB (button)
local teleportTab = Window:CreateTab("Teleport", "map-pin")
teleportTab:CreateSection("Teleport Tools")
local function playerListExceptLocal()
    local out = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer then table.insert(out, p.Name) end
    end
    if #out == 0 then table.insert(out, "No Players") end
    return out
end
local tpDropdown = teleportTab:CreateDropdown({
    Name = "Teleport Target",
    Options = playerListExceptLocal(),
    CurrentOption = {},
    MultipleOptions = false,
    Flag = "TeleportDropdown",
    Callback = function() end
})
local tpButton = teleportTab:CreateButton({
    Name = "Teleport To Player",
    Callback = function()
        local opt = tpDropdown.CurrentOption and tpDropdown.CurrentOption[1]
        if not opt or opt == "No Players" then Rayfield:Notify({Title="Teleport", Content="No target selected.", Duration=3}); return end
        local target = Players:FindFirstChild(opt)
        if target and target.Character and getHRP(target.Character) and getHRP(getCharacter()) then
            local hrp = getHRP(getCharacter())
            hrp.CFrame = getHRP(target.Character).CFrame + Vector3.new(0, 3, 0)
            Rayfield:Notify({Title="Teleport", Content="Teleported to "..opt, Duration=2})
        else
            Rayfield:Notify({Title="Teleport", Content="Target unavailable (maybe respawning).", Duration=3})
        end
    end
})
Players.PlayerAdded:Connect(function() tpDropdown:Refresh(playerListExceptLocal()) end)
Players.PlayerRemoving:Connect(function() tpDropdown:Refresh(playerListExceptLocal()) end)

-- FIGHTING TAB
local fightTab = Window:CreateTab("Fighting", "target")
fightTab:CreateSection("Combat Tools")

local aimbotToggle = fightTab:CreateToggle({
    Name = "Aimbot",
    CurrentValue = false,
    Flag = "AimbotToggle",
    Callback = function(on) end
})

local function currentPlayerNames()
    local names = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer then table.insert(names, p.Name) end
    end
    if #names == 0 then table.insert(names, "No Players") end
    return names
end
local aimbotTargetDropdown = fightTab:CreateDropdown({
    Name = "Aimbot Target Player",
    Options = currentPlayerNames(),
    CurrentOption = {},
    MultipleOptions = false,
    Flag = "AimbotTargetPlayer",
    Callback = function() end
})
Players.PlayerAdded:Connect(function() aimbotTargetDropdown:Refresh(currentPlayerNames()) end)
Players.PlayerRemoving:Connect(function() aimbotTargetDropdown:Refresh(currentPlayerNames()) end)

-- ESP
local espToggle = fightTab:CreateToggle({
    Name = "ESP (Highlight + Name)",
    CurrentValue = false,
    Flag = "ESPToggle",
    Callback = function(on) end
})
local espColorPicker = fightTab:CreateColorPicker({
    Name = "ESP Color",
    Color = Color3.fromRGB(255,0,0),
    Flag = "ESPColor",
    Callback = function(color) end
})

-- SETTINGS TAB (themes)
local settingsTab = Window:CreateTab("Settings", "sliders")
settingsTab:CreateSection("Theme Selector")
local themeOptions = {
    "Default - Default",
    "Amber Glow - AmberGlow",
    "Amethyst - Amethyst",
    "Bloom - Bloom",
    "Dark Blue - DarkBlue",
    "Green - Green",
    "Light - Light",
    "Ocean - Ocean",
    "Serenity - Serenity"
}
-- Dropdown shows user-friendly strings; we'll parse identifier after selection
local themeDropdown = settingsTab:CreateDropdown({
    Name = "Theme - Name (Identifier)",
    Options = themeOptions,
    CurrentOption = {"Default - Default"},
    MultipleOptions = false,
    Flag = "ThemeDropdown",
    Callback = function(opt)
        -- parse identifier after " - "
        local sel = opt and opt[1] or "Default - Default"
        local id = sel:match("%-%s*(%S+)%s*$") or "Default"
        -- safety: map some names -> identifiers (strip spaces)
        id = id:gsub("%s+", "")
        -- try to apply
        local applied = applyThemeByIdentifier(id, Window)
        -- save selection to config (Rayfield flags)
        pcall(function() Rayfield.Flags.LastThemeSelected:Set(sel) end)
        if applied then
            Rayfield:Notify({Title="Theme", Content="Applied theme: "..sel, Duration=2})
        else
            Rayfield:Notify({Title="Theme", Content="Theme set; reopen UI if it did not apply.", Duration=3})
        end
    end
})
-- add a hidden flag so selection is persisted
settingsTab:CreateLabel("Select a theme to apply. Selection is saved.", 0, nil, false)
-- create a persistent flag to hold last selection (so config saving stores it)
local _ = Window:CreateToggle({
    Name = "LastThemeSelected",
    CurrentValue = false,
    Flag = "LastThemeSelected",
    Callback = function() end
})

-- KEYBINDS TAB
local keybindsTab = Window:CreateTab("Keybinds", "keyboard")
keybindsTab:CreateSection("Keybinds")

local function toggleFlagByName(flagName)
    local f = Rayfield.Flags[flagName]
    if f then
        local val = f.Value
        f:Set(not val)
    end
end

-- Create the keybinds requested
local kb_speed = keybindsTab:CreateKeybind({
    Name = "Toggle Speed",
    CurrentKeybind = "F",
    HoldToInteract = false,
    Flag = "KB_Speed",
    Callback = function(held) if not held then toggleFlagByName("SpeedToggle") end end
})
local kb_jp = keybindsTab:CreateKeybind({
    Name = "Toggle JumpPower",
    CurrentKeybind = "G",
    HoldToInteract = false,
    Flag = "KB_Jump",
    Callback = function(held) if not held then toggleFlagByName("JumpToggle") end end
})
local kb_infjump = keybindsTab:CreateKeybind({
    Name = "Toggle Infinite Jump",
    CurrentKeybind = "H",
    HoldToInteract = false,
    Flag = "KB_InfJump",
    Callback = function(held) if not held then toggleFlagByName("InfJump") end end
})
local kb_noclip = keybindsTab:CreateKeybind({
    Name = "Toggle Noclip",
    CurrentKeybind = "J",
    HoldToInteract = false,
    Flag = "KB_Noclip",
    Callback = function(held) if not held then toggleFlagByName("Noclip") end end
})
local kb_esp = keybindsTab:CreateKeybind({
    Name = "Toggle ESP",
    CurrentKeybind = "U",
    HoldToInteract = false,
    Flag = "KB_ESP",
    Callback = function(held) if not held then toggleFlagByName("ESPToggle") end end
})
local kb_aim = keybindsTab:CreateKeybind({
    Name = "Aimbot (nearest while held)",
    CurrentKeybind = "I",
    HoldToInteract = true,
    Flag = "KB_AimNearest",
    Callback = function(held) aimingKeyHeld = held end
})
local kb_infhealth = keybindsTab:CreateKeybind({
    Name = "Toggle Infinite Health",
    CurrentKeybind = "Y",
    HoldToInteract = false,
    Flag = "KB_InfHealth",
    Callback = function(held) if not held then toggleFlagByName("InfiniteHealth") end end
})
local kb_antiafk = keybindsTab:CreateKeybind({
    Name = "Toggle Anti-AFK",
    CurrentKeybind = "O",
    HoldToInteract = false,
    Flag = "KB_AntiAFK",
    Callback = function(held) if not held then toggleFlagByName("AntiAFK") end end
})

-- ===================== Backend Logic =====================

-- Infinite jump
UserInputService.JumpRequest:Connect(function()
    if infJumpToggle and infJumpToggle.CurrentValue then
        local hum = getHumanoid()
        if hum then hum:ChangeState(Enum.HumanoidStateType.Jumping) end
    end
end)

-- Noclip loop
RunService.Stepped:Connect(function()
    if noclipToggle and noclipToggle.CurrentValue then
        local char = getCharacter()
        if char then
            for _, part in pairs(char:GetDescendants()) do
                if part:IsA("BasePart") then part.CanCollide = false end
            end
        end
    end
end)

-- Infinite health
RunService.Heartbeat:Connect(function()
    if infHealthToggle and infHealthToggle.CurrentValue then
        local hum = getHumanoid()
        if hum then hum.Health = hum.MaxHealth end
    end
end)

-- Anti-AFK: small camera nudge every 55s
spawn(function()
    while true do
        if antiAfkToggle and antiAfkToggle.CurrentValue then
            local cam = workspace.CurrentCamera
            if cam then
                local old = cam.CFrame
                cam.CFrame = old * CFrame.new(0,0.0001,0)
                wait(0.12)
                if cam then cam.CFrame = old end
            end
        end
        wait(55)
    end
end)

-- ===================== ESP: Highlight + Name =====================
local espTracks = {} -- player -> {highlight = instance, billboard = instance}

local function createNameBillboard(p)
    if not p.Character then return nil end
    local root = getHRP(p.Character)
    if not root then return nil end

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "HackerName"
    billboard.Adornee = root
    billboard.AlwaysOnTop = true
    billboard.Size = UDim2.new(0,150,0,30)
    billboard.StudsOffset = Vector3.new(0, 3.5, 0)
    billboard.ResetOnSpawn = false
    billboard.Parent = workspace.CurrentCamera

    local label = Instance.new("TextLabel", billboard)
    label.Size = UDim2.new(1,0,1,0)
    label.BackgroundTransparency = 1
    label.Text = p.Name
    label.TextScaled = true
    label.Font = Enum.Font.SourceSansBold
    label.TextStrokeTransparency = 0.6
    label.TextColor3 = espColorPicker.Color

    return billboard
end

local function applyESP(p)
    if p == LocalPlayer then return end
    if espTracks[p] then return end
    if not p.Character then return end

    local hl = Instance.new("Highlight")
    hl.Name = "HackerHighlight"
    hl.Adornee = p.Character
    hl.FillTransparency = 0.6
    hl.OutlineTransparency = 0.6
    hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    hl.FillColor = espColorPicker.Color
    hl.OutlineColor = espColorPicker.Color
    hl.Parent = workspace

    local bb = createNameBillboard(p)
    espTracks[p] = {highlight = hl, billboard = bb}
end

local function removeESP(p)
    local t = espTracks[p]
    if not t then return end
    if t.highlight then pcall(function() t.highlight:Destroy() end) end
    if t.billboard then pcall(function() t.billboard:Destroy() end) end
    espTracks[p] = nil
end

espToggle.Callback = function(on)
    if on then
        for _, p in ipairs(Players:GetPlayers()) do if p ~= LocalPlayer then applyESP(p) end end
    else
        for p, _ in pairs(espTracks) do removeESP(p) end
    end
end

espColorPicker.Callback = function(col)
    for _, t in pairs(espTracks) do
        if t.highlight then t.highlight.FillColor = col; t.highlight.OutlineColor = col end
        if t.billboard then
            local lbl = t.billboard:FindFirstChildOfClass("TextLabel")
            if lbl then lbl.TextColor3 = col end
        end
    end
end

Players.PlayerAdded:Connect(function(p)
    if espToggle and espToggle.CurrentValue and p ~= LocalPlayer then applyESP(p) end
    tpDropdown:Refresh(playerListExceptLocal())
    aimbotTargetDropdown:Refresh(currentPlayerNames())
end)
Players.PlayerRemoving:Connect(function(p)
    removeESP(p)
    tpDropdown:Refresh(playerListExceptLocal())
    aimbotTargetDropdown:Refresh(currentPlayerNames())
end)

-- Ensure existing players get ESP if enabled
if espToggle and espToggle.CurrentValue then
    for _, p in ipairs(Players:GetPlayers()) do if p ~= LocalPlayer then applyESP(p) end end
end

-- ===================== AIMBOT (fixed) =====================
-- right mouse hold -> aimingMouseDown; keybind hold -> aimingKeyHeld (already handled by keybind)
UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        aimingMouseDown = true
    end
end)
UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        aimingMouseDown = false
    end
end)

-- helper: nearest to screen center
local function findNearestPlayerToScreenCenter()
    local cam = workspace.CurrentCamera
    if not cam then return nil end
    local best, bestDist = nil, math.huge
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and p.Character then
            local part = p.Character:FindFirstChild("Head") or getHRP(p.Character)
            if part then
                local screen, on = cam:WorldToViewportPoint(part.Position)
                if on then
                    local center = Vector2.new(cam.ViewportSize.X/2, cam.ViewportSize.Y/2)
                    local d = (Vector2.new(screen.X, screen.Y) - center).Magnitude
                    if d < bestDist then bestDist = d; best = p end
                end
            end
        end
    end
    return best
end

local function getAimbotDropdownPlayer()
    local opt = aimbotTargetDropdown.CurrentOption and aimbotTargetDropdown.CurrentOption[1]
    if not opt or opt == "No Players" then return nil end
    return Players:FindFirstChild(opt)
end

RunService.Heartbeat:Connect(function(dt)
    if not workspace.CurrentCamera then return end
    local cam = workspace.CurrentCamera

    -- Determine if we should aim:
    -- - If Aimbot toggle ON and right mouse held -> aim at selected player (if any)
    -- - If aimbot keybind held (aimingKeyHeld true) -> aim at nearest
    local shouldAimWithDropdown = (aimbotToggle and aimbotToggle.CurrentValue and aimingMouseDown)
    local shouldAimNearest = aimingKeyHeld

    if not shouldAimWithDropdown and not shouldAimNearest then return end

    local targetPlayer = nil
    if shouldAimNearest then
        targetPlayer = findNearestPlayerToScreenCenter()
    else
        targetPlayer = getAimbotDropdownPlayer()
    end

    if targetPlayer and targetPlayer.Character then
        local targetPart = targetPlayer.Character:FindFirstChild("Head") or getHRP(targetPlayer.Character)
        if targetPart then
            local desired = CFrame.new(cam.CFrame.Position, targetPart.Position)
            cam.CFrame = cam.CFrame:Lerp(desired, math.clamp(10 * dt, 0, 1))
        end
    end
end)

-- ===================== Finalize: Load saved config & set initial theme if present =====================
-- If user previously saved a theme string, try to load it from the saved flags.
-- Rayfield saves flags into config; attempt reading LastThemeSelected flag we used earlier.
Rayfield:LoadConfiguration()

-- After loading config, attempt to read persisted theme selection
local persistedTheme = nil
pcall(function()
    -- We stored selection as the toggle "LastThemeSelected" content earlier; but flag storage varies by Rayfield version.
    if Rayfield.Flags and Rayfield.Flags.LastThemeSelected then
        local raw = Rayfield.Flags.LastThemeSelected.Value
        if type(raw) == "string" and raw:match("%-") then
            persistedTheme = raw:match("%-%s*(%S+)%s*$")
        end
    end
end)
if persistedTheme then
    persistedTheme = persistedTheme:gsub("%s+", "")
    local applied = applyThemeByIdentifier(persistedTheme, Window)
    if applied then
        Rayfield:Notify({Title="Theme", Content="Loaded theme: "..tostring(persistedTheme), Duration=2})
    end
end

-- Friendly startup notification
Rayfield:Notify({
    Title = "Hacking Sim Loaded",
    Content = "Local simulator ready. Use in Studio/test places only.",
    Duration = 4
})
